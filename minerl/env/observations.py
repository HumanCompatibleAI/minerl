from copy import deepcopy
import os
import functools
import np

dir_path = os.path.dirname(os.path.realpath(__file__))


def get_item_block_lists():
    """
    :return: items: a list of strings, corresponding to minecraft items in a player's inventory.
            blocks: a list of strings, corresponding to minecraft blocks in the world.

        Where do items.txt and blocks.txt come from? Better for your sanity if you pretend they're magic.

        Malmo has two files: `Schemas/MinecraftItems.txt` and `Schemas/MinecraftBlocks.txt`.
        You will note the item list is not exhaustive - it doesn't have dirt, and that can be in an inventory.
        So, look at items.json. That seems like an exhaustive list of inventory items.
        However, it has more entries than MinecraftItems.txt and MinecraftBlocks.txt combined. i.e., both are wrong.
        So, we use items.json for our items list. For our block list, we use the `Blocks` section of `Schemas/Types.xsd`
        Why do we use that? It has a reasonable length. I have no means to confirm its accuracy.
    """
    items_file = os.path.join(dir_path, 'data', 'items.txt')
    blocks_file = os.path.join(dir_path, 'data', 'blocks.txt')
    if not (os.path.isfile(items_file) and os.path.isfile(blocks_file)):
        print("Could not find item and block data!")
        return None

    with open(items_file) as f:
        items = [line.strip() for line in f]
    with open(blocks_file) as f:
        blocks = [line.strip() for line in f]

    return items, blocks


ITEMS, BLOCKS = get_item_block_lists()
# Use these for observation spaces that interact with minecraft items and blocks.
#   Provides a non-meaningful but consistent ordering over the space of names.
# Currently no support for entities.


def key_observation(info, obs_space, key):
    """
    :param info: Info dict generated by Malmo mod. Must contain key.
    :param obs_space: unused.
    :param key: key to access in info dict.
    :return: info[key]
    """
    return info[key]


pov_observation = functools.partial(key_observation, key="pov")

compass_observation = functools.partial(key_observation, key="compassAngle")


def inventory_observation(info, obs_space):
    """
    For every item type in the observation space, add up how many of said item are in the inventory.
    Duplicates the MineRL default inventory observation.

    :param info: Info dict generated by Malmo mod.
    :param obs_space: The observation space. Used to decide which item information to include.
    :return: Dict of {item name : count in inventory}.
    """
    inventory_spaces = obs_space['inventory'].spaces

    inventory_dict = {k: 0 for k in inventory_spaces}
    # TODO change to maalmo
    if 'inventory' in info:
        for stack in info['inventory']:
            if 'type' in stack and 'quantity' in stack:
                type_name = stack['type']
                if type_name == 'log2':
                    type_name = 'log'

                try:
                    inventory_dict[type_name] += stack['quantity']
                except ValueError:
                    continue
                except KeyError:
                    # We only care to observe what was specified in the space.
                    continue
    else:
        print("Inventory information could not be found, returning empty inventory.")

    return inventory_dict


def mainhand_observation(info, obs_space):
    """ TODO: THIS LOOKS DIFFERENT FROM MINERL MAIN, CHANGES TO CORE NEEDED."""
    mainhand_dict = {}
    try:
        mainhand_dict['equipped_items.mainhand.type'] = info['equipped_items']['mainhand']['type']
        mainhand_dict['equipped_items.mainhand.damage'] = np.array(info['equipped_items']['mainhand']['damage'])
        mainhand_dict['equipped_items.mainhand.maxDamage'] = np.array(info['equipped_items']['mainhand']['maxDamage'])
    except Exception as e:
        if 'equipped_items' in info:
            del info['equipped_items']

    # bottom_env_spec = self.env_spec
    # while isinstance(bottom_env_spec, EnvWrapper):
    #     bottom_env_spec = bottom_env_spec.env_to_wrap

    try:
        if mainhand_dict['equipped_items.mainhand.type'] not in obs_space['equipped_items.mainhand.type']:
            mainhand_dict['equipped_items.mainhand.type'] = "other"  # Todo: use handlers. TODO: USE THEM<
    except Exception as e:
        pass

    return mainhand_dict